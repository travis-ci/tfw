#!/usr/bin/env bash
# vim:expandtab:ts=2:sw=2:
set -o errexit
set -o pipefail

if [[ "${DEBUG}" ]]; then
  set -o xtrace
fi

__TFW_VERSION__='v0.1.0'
declare -A __TFW_ALIASES__
declare -A __TFW_HELP_DOC__

__TFW_DEPENDENCIES__=(
  'awk'
  'bash'
  'cat'
  'chmod'
  'chown'
  'curl'
  'cut'
  'dirname'
  'docker'
  'getent'
  'hostname'
  'jq'
  'mdadm'
  'mkdir'
  'mktemp'
  'rm'
  'ssh-import-id'
  'ssh-keygen'
  'systemctl'
  'tee'
  'useradd'
)

main() {
  for key in "${!__TFW_ALIASES__[@]}"; do
    eval "__run_${key}() { __run_${__TFW_ALIASES__[${key}]} \"\${@}\"; }"
  done

  : "${DEVDIR:=/dev}"
  : "${ETCDIR:=/etc}"
  : "${RUNDIR:=/var/tmp/travis-run.d}"
  : "${TMPDIR:=/tmp}"
  : "${USRBINDIR:=/usr/bin}"
  : "${USRSBINDIR:=/usr/sbin}"
  : "${VARCACHEDIR:=/var/cache}"
  : "${VARLIBDIR:=/var/lib}"

  local command="${1}"
  shift || true
  if "__run_${command:-help}" "${@}"; then
    exit 0
  fi
  __run_help '' 1
}

# <command[,alias,alias]> <docs>
# Define the documentation and optional aliases for a given command.
def() {
  read -r -a dest_aliases <<<"${1//,/ }"
  shift
  local docs="${1}"
  shift || true

  local dest="${dest_aliases[0]}"

  __TFW_HELP_DOC__[${dest}]="${docs}"
  for key in "${dest_aliases[@]:1}"; do
    __TFW_ALIASES__[${key}]="${dest}"
    __TFW_HELP_DOC__[${key}]="${docs}"
  done
}

__error() {
  echo "tfw:ERROR: ${*}" >&2
}

__warn() {
  echo "tfw:WARN: ${*}" >&2
}

__info() {
  echo "tfw:INFO: ${*}" >&2
}

def help,h,-h,--help "[topic] [exit-code]

Get more help about a topic, optionally injecting an exit code (mostly used
internally)."
__run_help() {
  local topic="${1}"
  local exit_code="${2:-0}"

  if [[ "${topic}" ]]; then
    if [[ ${__TFW_HELP_DOC__[${topic}]} ]]; then
      echo -n "Usage: tfw ${topic} "
      cat <<<"${__TFW_HELP_DOC__[${topic}]}"
      exit "${exit_code}"
    else
      echo "ERROR: No help available for topic '${topic}'" >&2
    fi
  fi

  cat <<'EOUSAGE'
tfw <command> [${more-stuff(1)}, ${maybe(2)}]

  help, h, -h, --help       - echo this string or get help for another command
  version, v, -v, --version - echo version and exit

  bootstrap, b

Docker image configuration and deployment stuff:

  app-extract, extract, e
  app-printenv, printenv, p
  app-writeenv, writeenv, w

Junk drawer utility stuff:

  urldecode, d
  gsub, g

Administrivia:

  admin-bootstrap
  admin-hostname
  admin-raid
  admin-rsyslog
  admin-ssh
  admin-travis-sudo
  admin-users

EOUSAGE
  exit "${exit_code}"
}

def version,v,-v,--version "

Print the version and exit 0, and that's about it!"
__run_version() {
  echo "${__TFW_VERSION__}"
  exit 0
}

def urldecode,d "<url-encoded-string> [url-encoded-string, ...]

URL-decode any number of positional argument strings, handling 'quote plus'
encoding as well, e.g.

  tfw urldecode what%2Fthe+what%3F"
__run_urldecode() {
  : "${*//+/ }"
  echo -e "${_//%/\\x}"
}

def bootstrap,b "
Ensure dependencies are present on the system; intended to be run early in
instance preparation.

NOTE: \${RUNDIR} is used as prefix for cached calculated values
NOTE: \${TMPDIR} is used for temporary file bits
NOTE: \${USRBINDIR} is used as prefix installed executables
"
__run_bootstrap() {
  mkdir -p "${RUNDIR}"

  __bootstrap_jq
  __bootstrap_apt
  __bootstrap_docker

  for cmd in "${__TFW_DEPENDENCIES__[@]}"; do
    if ! command -v "${cmd}" &>/dev/null; then
      __warn "Could not find dependency '${cmd}'"
    fi
  done
}

__bootstrap_jq() {
  if jq --version; then
    return
  fi

  curl -sSL \
    -o "${TMPDIR}/jq" \
    'https://github.com/stedolan/jq/releases/download/jq-1.5/jq-linux64'
  chmod +x "${TMPDIR}/jq"
  mv -v "${TMPDIR}/jq" "${USRBINDIR}/jq"
}

__bootstrap_apt() {
  if ! apt-get --version &>/dev/null; then
    return
  fi

  systemctl disable apt-daily || true
  systemctl stop apt-daily || true
  systemctl disable apt-daily-upgrade || true
  systemctl stop apt-daily-upgrade || true

  apt-get update -yqq
  touch "${VARLIBDIR}/apt/periodic/update-success-stamp"

  for d in "${VARCACHEDIR}/local" "${VARCACHEDIR}/local/preseeding"; do
    mkdir -p "${d}"
    chown root:root "${d}"
    chmod 0755 "${d}"
  done

  apt-get install -yqq \
    apt-transport-https \
    curl \
    debian-archive-keyring \
    openssh-client \
    openssh-server \
    rsyslog \
    rsyslog-gnutls \
    software-properties-common \
    sudo
}

__bootstrap_docker() {
  if docker version; then
    return
  fi

  curl -sSL https://get.docker.io | bash
}

def app-printenv,printenv,p "<name> [outfile] [-E/--export]

Print the combined configuration for a given thing by name, optionally writing
to a second \${outfile} argument.  If -E/--export is given, then any leading
\"export \" statements will not be stripped.

NOTE: \${ETCDIR} is used as prefix for \${ETCDIR}/default/"
__run_app-printenv() {
  local name="${1}"
  if [[ ! "${name}" ]]; then
    __error 'Missing positional argument for name'
    __run_help printenv 2
  fi
  shift

  local out="${1}"
  shift || true

  local leave_exports
  for arg in "${@}"; do
    if [[ "${arg}" =~ ^-E|--export$ ]]; then
      leave_exports=1
    fi
  done

  if [[ "${out}" ]]; then
    echo "${out}"
    exec 1>"${out}"
  fi

  for config_file in \
    travis-enterprise \
    "${name}-chef" \
    "${name}" \
    "${name}-cloud-init" \
    "${name}-local"; do
    if [ -f "${ETCDIR}/default/${config_file}" ]; then
      echo "# ${ETCDIR}/default/${config_file}"
      while read -r line; do
        line="${line//\'/}"
        if [[ ! "${leave_exports}" ]]; then
          line="${line##export }"
        fi
        echo "${line//\"/}"
      done <"${ETCDIR}/default/${config_file}"
    fi
  done
}

def app-writeenv,writeenv,w "<name> [dest-basename]

Write the combined configuration for a given thing by name to \${RUNDIR}/,
defaulting to \${RUNDIR}/\${name}.env, but optionally to a custom dest basename.

NOTE: \${ETCDIR} is used as prefix for \${ETCDIR}/default/\
NOTE: \${RUNDIR} is used as prefix for \${RUNDIR}/\${name}.env"
__run_app-writeenv() {
  local dest_basename="${2:-${1}}"
  local dest="${RUNDIR:-/var/tmp/travis-run.d}/${dest_basename}.env"
  mkdir -p "$(dirname "${dest}")"
  __run_app-printenv "${1}" "${dest}"
}

def app-extract,extract,e "<name> <image>

Extract systemd service definition and wrapper script, if present, from a given
docker \${image} to system destinations, defaults being:

service definition: \${ETCDIR:-/etc}/systemd/system/\${name}.service
wrapper script:     \${USRSBINDIR:-/usr/sbin}/\${name}-wrapper

NOTE: \${ETCDIR} is used as prefix for \${ETCDIR}/systemd/system\${name}.service
NOTE: \${USRSBINDIR} is used as prefix for \${USRSBINDIR}/\${name}-wrapper"
__run_app-extract() {
  local name="${1}"
  local image="${2}"

  if [[ ! "${name}" ]]; then
    __error 'Missing positional argument for name'
    __run_help extract 2
  fi

  if [[ ! "${image}" ]]; then
    __error 'Missing positional argument for image'
    __run_help extract 2
  fi

  local tmp_dest_prefix
  tmp_dest_prefix="$(mktemp -d)"
  local service_dest="${ETCDIR:-/etc}/systemd/system/${name}.service"
  local service_dest_tmp="${tmp_dest_prefix}/${name}.service"
  local wrapper_dest="${USRSBINDIR:-/usr/sbin}/${name}-wrapper"
  local wrapper_dest_tmp="${tmp_dest_prefix}/${name}-wrapper"

  local tmpcontainer
  tmpcontainer="$(docker run -d --rm "${image}" sh -c "sleep 10")"

  if docker cp "${tmpcontainer}:/app/systemd.service" "${service_dest_tmp}"; then
    local dest
    dest="$(__run_gsub "${name}" "${service_dest_tmp}" "${service_dest}")"
    echo "Extracted ${dest}"
  else
    echo "WARN: No systemd.service file found for ${name}" >&2
  fi

  if docker cp "${tmpcontainer}:/app/systemd-wrapper" "${wrapper_dest_tmp}"; then
    local dest
    dest="$(__run_gsub "${name}" "${wrapper_dest_tmp}" "${wrapper_dest}")"
    if [[ -w "${dest}" ]]; then
      chmod +x "${dest}"
      __info "Extracted ${dest}"
    else
      __error "Failed to extract ${wrapper_dest}"
    fi
  else
    __warn "No systemd wrapper executable found for ${name}"
  fi
}

def gsub,s "<name> <infile> [outfile]

Substitute strings with platform and instance-dependent runtime values,
optionally writing to an output file.

  ___INSTANCE_ID___   - instance identifier, e.g. i-fafafaf
  ___INSTANCE_NAME___ - instance name, e.g. production-8-juicero-f-2-gce
  ___INSTANCE_IPV4___ - instance ipv4 address, e.g. 10.10.9.8
  ___REGION_ZONE__    - region + zone, e.g. us-central1-d
"
__run_gsub() {
  local name="${1}"
  shift
  local infile="${1}"
  shift || true

  if [[ ! "${name}" ]]; then
    __error 'Missing positional argument for name'
    __run_help gsub 2
  fi

  if [[ ! "${infile}" ]]; then
    __error 'Missing positional argument for input file'
    __run_help gsub 2
  fi

  if [[ ! -r "${infile}" ]]; then
    __error 'Input file is not readable'
    __run_help gsub 2
  fi

  local out="${1}"

  if [[ "${out}" ]]; then
    echo "${out}"
    exec 1>"${out}"
  fi

  local instance_ipv4 instance_id instance_name region_zone
  instance_ipv4="$(__get_instance_ipv4)"
  instance_id="$(__get_instance_id)"
  instance_name="$(__get_instance_name)"
  region_zone="$(__get_instance_region_zone)"
  local systemd_wrapper_path
  systemd_wrapper_path="${USRSBINDIR}/${name}-wrapper"

  while IFS= read -r line; do
    line="${line//___SYSTEMD_WRAPPER___/${systemd_wrapper_path}}"
    line="${line//___INSTANCE_IPV4___/${instance_ipv4}}"
    line="${line//___INSTANCE_ID___/${instance_id}}"
    line="${line//___INSTANCE_NAME___/${instance_name}}"
    line="${line//___REGION_ZONE___/${region_zone}}"
    echo "${line}"
  done <"${infile}"
}

__get_instance_ipv4() {
  __ensure_instance_metadata

  local value='127.0.0.1'
  if [[ -s "${RUNDIR}/instance-ipv4" ]]; then
    value="$(cat "${RUNDIR}/instance-ipv4")"
  fi
  echo "${value}"
}

__get_instance_id() {
  __ensure_instance_metadata

  local value='i-fafafaf'
  if [[ -s "${RUNDIR}/instance-id" ]]; then
    value="$(cat "${RUNDIR}/instance-id")"
  fi
  echo "${value}"
}

__get_instance_name() {
  __ensure_instance_metadata

  local value='notset'
  if [[ -s "${RUNDIR}/instance-name" ]]; then
    value="$(cat "${RUNDIR}/instance-name")"
  fi
  echo "${value}"
}

__get_instance_region_zone() {
  __ensure_instance_metadata

  local value='notset'
  if [[ -s "${RUNDIR}/instance-region-zone" ]]; then
    value="$(cat "${RUNDIR}/instance-region-zone")"
  fi
  echo "${value}"
}

__ensure_instance_metadata() {
  if [[ -s "${RUNDIR}/instance-id" ]] &&
    [[ -s "${RUNDIR}/instance-name" ]] &&
    [[ -s "${RUNDIR}/instance-ipv4" ]] &&
    [[ -s "${RUNDIR}/instance-region-zone" ]]; then
    return
  fi

  if __fetch_instance_metadata_ec2; then
    return
  fi

  if __fetch_instance_metadata_gce; then
    return
  fi

  if __fetch_instance_metadata_packet; then
    return
  fi

  __warn 'Failed to fetch any instance metadata'
}

__fetch_instance_metadata_ec2() {
  local ec2_metadata='http://169.254.169.254/latest/meta-data'
  if ! curl --connect-timeout 3 -sfSL \
    "${ec2_metadata}/instance-id" &>/dev/null; then
    return 1
  fi

  curl -sSL "${ec2_metadata}/instance-id" >"${RUNDIR}/instance-id"
  local instance_id
  instance_id="$(cat "${RUNDIR}/instance-id")"
  echo "${instance_id:0:9}" >"${RUNDIR}/instance-name"
  curl -sSL "${ec2_metadata}/local-ipv4" >"${RUNDIR}/instance-ipv4"
  curl -sSL "${ec2_metadata}/placement/availability-zone" \
    >"${RUNDIR}/instance-region-zone"
  return 0
}

__fetch_instance_metadata_gce() {
  local gce_metadata='http://metadata.google.internal/computeMetadata/v1'
  if ! curl --connect-timeout 3 -sfSL -H 'Metadata-Flavor: Google' \
    "${gce_metadata}/instance" &>/dev/null; then
    return 1
  fi

  curl -sSL -H 'Metadata-Flavor: Google' \
    "${gce_metadata}/instance/id" >"${RUNDIR}/instance-id"
  curl -sSL -H 'Metadata-Flavor: Google' \
    "${gce_metadata}/instance/name" >"${RUNDIR}/instance-name"
  curl -sSL -H 'Metadata-Flavor: Google' \
    "${gce_metadata}/instance/network-interfaces/0/ip" \
    >"${RUNDIR}/instance-ipv4"
  curl -sSL -H 'Metadata-Flavor: Google' \
    "${gce_metadata}/instance/zone" |
    awk -F/ '{ print $NF }' >"${RUNDIR}/instance-region-zone"
  return 0
}

__fetch_instance_metadata_packet() {
  local packet_metadata='https://metadata.packet.net/metadata'
  if ! curl --connect-timeout 3 -sfSL "${packet_metadata}" &>/dev/null; then
    return 1
  fi

  curl -sSL "${packet_metadata}" >"${RUNDIR}/metadata.json"
  jq -r .id <"${RUNDIR}/metadata.json" | cut -d- -f 1 |
    tee "${RUNDIR}/instance-name" >"${RUNDIR}/instance-id"
  jq -r ".network.addresses | .[] | \
    select(.address_family==4 and .public==false) | \
    .address" <"${RUNDIR}/metadata.json" >"${RUNDIR}/instance-ipv4"
  jq -r .facility <"${RUNDIR}/metadata.json" >"${RUNDIR}/instance-region-zone"
  return 0
}

def admin-bootstrap "

Run all admin-* tasks, attempting to fetch configuration from \${ETCDIR}/default
files in the following order, with relevant variables:

\${ETCDIR}/default/tfw
  + TFW_FAIL2BAN_SSH_BANTIME - int for fail2ban ssh jail ban time
  + TFW_FAIL2BAN_SSH_MAXRETRY - int for fail2ban ssh jail ban retries
  + TFW_GITHUB_USERS - \" \"-delimited username:github-login pairs
  + TFW_SSH_KEYALGO_BITS  - \" \"-delimited algo:nbits pairs for ssh keygen

\${ETCDIR}/default/fail2ban-ssh
  + FAIL2BAN_SSH_BANTIME (falls back to TFW_FAIL2BAN_SSH_BANTIME)
  + FAIL2BAN_SSH_MAXRETRY (falls back to TFW_FAIL2BAN_SSH_MAXRETRY)

\${ETCDIR}/default/github-users
  + GITHUB_USERS (falls back to TFW_GITHUB_USERS)
"
__run_admin-bootstrap() {
  if [[ -f "${ETCDIR}/default/tfw" ]]; then
    # shellcheck source=/dev/null
    source "${ETCDIR}/default/tfw"
  fi

  if [[ -f "${ETCDIR}/default/fail2ban-ssh" ]]; then
    # shellcheck source=/dev/null
    source "${ETCDIR}/default/fail2ban-ssh"

    : "${FAIL2BAN_SSH_MAXRETRY:=${TFW_FAIL2BAN_SSH_MAXRETRY}}"
    : "${FAIL2BAN_SSH_BANTIME:=${TFW_FAIL2BAN_SSH_BANTIME}}"
  fi

  if [[ -f "${ETCDIR}/default/github-users" ]]; then
    # shellcheck source=/dev/null
    source "${ETCDIR}/default/github-users"

    : "${GITHUB_USERS:=${TFW_GITHUB_USERS}}"
  fi

  local github_users
  read -r -a github_users <<<"${GITHUB_USERS}"
  __run_admin-users "${github_users[@]}"

  __run_admin-travis-sudo

  local ssh_keyalgo_bits
  read -r -a ssh_keyalgo_bits <<<"${TFW_SSH_KEYALGO_BITS}"
  __run_admin-ssh \
    "${FAIL2BAN_SSH_MAXRETRY}" "${FAIL2BAN_SSH_BANTIME}" \
    "${ssh_keyalgo_bits[@]}"

  __run_admin-hostname "${TFW_HOSTNAME_TEMPLATE}"
  __run_admin-rsyslog "${TFW_SYSLOG_ADDRESS}"
}

def admin-users "<username:github-login> [username:github-login, ]

Ensure local users exist with SSH authorized keys added from GitHub.
"
__run_admin-users() {
  local username github_username

  for pair in "${@}"; do
    username="${pair%%:*}"
    github_username="${pair##*:}"

    if [[ ! "${username}" ]]; then
      continue
    fi

    __create_user "${username}"
    __stub_zshrc "${username}"

    if [[ ! "${github_username}" ]]; then
      continue
      __add_github_keys "${username}" "${github_username}"
    fi
  done
}

__create_user() {
  local username="${1}"

  if getent passwd "${username}"; then
    return
  fi

  useradd \
    -G sudo \
    -U \
    -d "/home/${username}" \
    -m \
    -s /bin/zsh \
    "${username}"
}

__stub_zshrc() {
  local username="${1}"
  local zshrc="/home/${username}/.zshrc"

  if [[ -s "${zshrc}" ]]; then
    return
  fi

  echo '# this space intentionally left blank' >"${zshrc}"
  chmod 0640 "${zshrc}"
  chown "${username}:${username}" "${zshrc}"
}

__add_github_keys() {
  local username="${1}"
  local github_username="${2}"
  local ssh_dir="/home/${username}/.ssh"

  mkdir -p "${ssh_dir}"
  chmod 0700 "${ssh_dir}"

  URL=https://github.com/%s.keys \
    ssh-import-id -o "${ssh_dir}/authorized_keys" "${github_username}"
  chown -R "${username}:${username}" "${ssh_dir}"
}

def admin-travis-sudo "

Disable sudo access for travis user if it exists.
"
__run_admin-travis-sudo() {
  rm -vf "${ETCDIR}/sudoers.d/travis"
}

def admin-ssh "[ssh-maxretry] [ssh-bantime] [keyalgo:bits, keyalgo:bits, ...]

Enable and configure SSH server keys and fail2ban SSH jail.
"
__run_admin-ssh() {
  local ssh_maxretry="${1}"
  shift || true
  local ssh_bantime="${2}"
  shift || true
  __enable_fail2ban_ssh_jail "${ssh_maxretry}" "${ssh_bantime}"
  __ensure_server_ssh_keys "${@}"
}

__enable_fail2ban_ssh_jail() {
  local ssh_maxretry="${1:-4}"
  local ssh_bantime="${2:-86400}"
  local confdir="${ETCDIR}/fail2ban"

  cat >"${confdir}/jail.d/99-enable-ssh.local" <<EOF
# Written via tfw :heart:
[ssh]
enabled = true
maxretry = ${ssh_maxretry}
bantime = ${ssh_bantime}
EOF

  systemctl stop fail2ban || true
  systemctl start fail2ban || true
}

__ensure_server_ssh_keys() {
  local ssh_keys=("${@}")

  if [[ "${#ssh_keys[@]}" -eq 0 ]]; then
    ssh_keys=(rsa:4096 ecdsa:521 ed25519:256)
  fi

  for key in "${ssh_keys[@]}"; do
    local keytype="${key%%:*}"
    local keybits="${key##*:}"
    local keyfile="${ETCDIR}/ssh/ssh_host_${keytype}_key"

    if [ -f "${keyfile}" ]; then
      __info "'${keytype}' key (${keyfile}) already exists; not regenerating."
      continue
    fi

    __info "generating '${keytype}' key (${keyfile}); this may take some time..."
    ssh-keygen -q -f "${keyfile}" -N '' -t "${keytype}" -b "${keybits}"
    ssh-keygen -l -f "${keyfile}.pub"
  done
}

def admin-hostname "[hostname-template]

Set system hostname and add /etc/hosts record based on runtime values and
optional {hostname-template} (default=\${RUNDIR}/instance-hostname.tmpl).
"
__run_admin-hostname() {
  local hostname_template="${1:-${RUNDIR}/instance-hostname.tmpl}"
  local hosts_line
  local instance_hostname
  instance_hostname="$(__run_gsub 'instance-hostname' "${hostname_template}")"

  if [[ ! "${instance_hostname}" ]]; then
    __warn 'No instance hostname generated'
  fi

  hosts_line="$(__get_instance_ipv4)"
  if [[ "${hosts_line}" ]]; then
    hosts_line="${hosts_line} ${instance_hostname} ${instance_hostname%%.*}"
  fi

  echo "${instance_hostname}" >"${ETCDIR}/hostname"
  echo "${instance_hostname}" >"${RUNDIR}/instance-hostname"

  hostname -F "${ETCDIR}/hostname"

  if ! grep -q "^${hosts_line}" "${ETCDIR}/hosts"; then
    echo "${hosts_line}" >>"${ETCDIR}/hosts"
  fi
}

def admin-rsyslog "[syslog-address]

Ensure rsyslog forwarding is enabled if a [syslog-address] is available, reading
from \${RUNDIR}/syslog-address by default.
"
__run_admin-rsyslog() {
  local syslog_address="${1}"
  local rsyslog_papertrail_conf="${ETCDIR}/rsyslog.d/65-papertrail.conf"
  local syslog_address_file="${RUNDIR}/syslog-address"

  if [[ ! "${syslog_address}" ]]; then
    syslog_address="$(cat "${syslog_address_file}" 2>/dev/null)"
  fi

  if [[ ! "${syslog_address}" ]]; then
    __error "Missing \${syslog_address}"
    __run_help admin-rsyslog 2
  fi

  mkdir -p "$(dirname "${rsyslog_papertrail_conf}")"
  touch "${rsyslog_papertrail_conf}"
  sed -i '/^\*\.\*.*@/d' "${rsyslog_papertrail_conf}"
  echo "*.* @${syslog_address}" >>"${rsyslog_papertrail_conf}"

  systemctl stop rsyslog || true
  systemctl start rsyslog || true
}

def admin-raid "[device] [raid-level]

Set up a multi-disk volume at [device] (default /dev/md0) with raid level
[raid-level] (default 0) from all available disks, as determined by looking at
all available /dev/sd* devices.
"
__run_admin-raid() {
  local device="${1:-/dev/md0}"
  local raid_level="${2:-0}"

  if [[ -e "${device}" ]]; then
    return
  fi

  local raid_devices=()
  local devx="${DEVDIR}/sdx"
  local max_devlen="${#devx}"

  for d in "${DEVDIR}/sd"*; do
    if [[ "${#d}" -gt "${max_devlen}" ]]; then
      continue
    fi
    raid_devices=("${d}" "${raid_devices[@]}")
  done

  mdadm \
    --create "${device}" \
    --level="${raid_level}" \
    --raid-devices="${#raid_devices[@]}" \
    "${raid_devices[@]}"
}

main "${@}"
